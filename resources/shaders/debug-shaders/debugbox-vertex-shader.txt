// See notes/debugbox-vertex-shader-notes.txt

// MEtodi di debug per shaders
// - Geometry shaders for vector quantities: use the geometry shader to create vector which shows vector quantities
// - Value ranges checks with colors
// - Value distribution checks with colors

#version 330
uniform mat4 MVP;
uniform int outline;
uniform float screen_width_ratio;

in vec2 vPos;

out vertex{
	vec2 borderCoord;
	vec2 vertex_normal_ndc;
	vec3 debug_color;
} vs_out;


// Trasforma in coordinate ndc ciascun vertice del box renderizzato.
// Se il box è taggato "outlined", trasla ciascun vertice in relazione alle normali degli edges adiacenti, così
// da "esplodere" il box 
// Se il box è taggato "outlined", associa a ciascun vertice una coordinata con valore assoluto maggiore di 1, 
// in modo tale che la parte di box aggiunta dall'esplosione abbia fragment con coordinate uv comprese tra 1+x e 1 
// mentre l'area del box originale (non esploso) da 1 a 0.
void main()
{

	float border_width = 0.4f * outline;

	// Transform important box points from model-space to ndc
	vec4 box_center_ndc = MVP * vec4( 0.0, 0.0, 0.0, 1.0);
	vec4 box_vertex_ndc = MVP * vec4( vPos.x, vPos.y , 0.0, 1.0) ;
	vec4 box_right_edge_mid_point_ndc = MVP * vec4(vPos.x , 0.0, 0.0, 1.0 );
	vec4 box_top_edge_mid_point_ndc = MVP * vec4(0.0,  vPos.y, 0.0, 1.0 );

	// Calculate important box vectors in ndc
	vec2 box_center_to_right_edge_midpoint_ndc = vec2( box_right_edge_mid_point_ndc.x - box_center_ndc.x , box_right_edge_mid_point_ndc.y - box_center_ndc.y);
	vec2 box_center_to_top_edge_midpoint_ndc = vec2( box_top_edge_mid_point_ndc.x - box_center_ndc.x , box_top_edge_mid_point_ndc.y - box_center_ndc.y);
	
	// Proportionate the previous points dimensions
	box_center_to_right_edge_midpoint_ndc.x = box_center_to_right_edge_midpoint_ndc.x * screen_width_ratio;
	box_center_to_top_edge_midpoint_ndc.x = box_center_to_top_edge_midpoint_ndc.x * screen_width_ratio;

	// BUILD THE VERTEX NDC EXPLODED COORDINATE 
	
	vec2 box_right_edge_normal_ndc = normalize( box_center_to_right_edge_midpoint_ndc );
	vec2 box_top_edge_normal_ndc = normalize( box_center_to_top_edge_midpoint_ndc );
	vec2 box_vertex_ndc_offset = normalize( box_right_edge_normal_ndc + box_top_edge_normal_ndc );
	float rigth_edge_width = dot( box_right_edge_normal_ndc, box_vertex_ndc_offset );
	float top_edge_width = dot( box_top_edge_normal_ndc, box_vertex_ndc_offset );
	box_vertex_ndc_offset.x = box_vertex_ndc_offset.x / screen_width_ratio;	// go back to original ndc before sending out the vertex ndc output
	gl_Position = vec4( box_vertex_ndc.x + box_vertex_ndc_offset.x * border_width , box_vertex_ndc.y + box_vertex_ndc_offset.y  * border_width , outline * 0.5, 1.0 );

	// BUILD THE VERTEX UV PROPERTY	
	// Associa al vertice del box una coordinata uv in modo tale che, solo se il box renderizzato è exploded,
	// il valore della coordinata è >1 e tale per cui i vertici del box non esploso corrispondano ancora ad 1

	box_vertex_ndc_offset.x = box_vertex_ndc_offset.x * screen_width_ratio;
	vec2 norm_right = normalize(box_center_to_right_edge_midpoint_ndc);
	vec2 norm_top = normalize(box_center_to_top_edge_midpoint_ndc);
	float len_right = length(box_center_to_right_edge_midpoint_ndc);
	float len_top = length(box_center_to_top_edge_midpoint_ndc);
	float len_right_out = length(box_center_to_right_edge_midpoint_ndc + norm_right * dot(norm_right, box_vertex_ndc_offset * border_width));
	float len_top_out = length(box_center_to_top_edge_midpoint_ndc + norm_top * dot(norm_top, box_vertex_ndc_offset * border_width));

	vs_out.borderCoord = vec2( 
			( len_right_out * outline) / len_right * sign(vPos.x) ,
			( len_top_out * outline) / len_top * sign(vPos.y) );
	
	// DEBUGGING OUTPUTS
	// vs_out.vertex_normal_ndc = box_right_edge_normal_ndc;	
	// vs_out.debug_color = vec3( ( len_right_out ) / len_right * sign(vPos.x), ( len_top_out ) / len_top * sign(vPos.y), 0 );

}

// L'idea è questa:




