#version 330
uniform mat4 MVP;
uniform int outline;
uniform float screen_width_ratio;

in vec2 vPos;

out vertex{
	vec2 borderCoord;
	vec2 vertex_normal_ndc;
	vec3 debug_color;
} vs_out;

void ooo_main()
{

	float border_width = 0.01f * outline;

	// Transform important box points to ndc
	vec4 box_center_ndc = MVP * vec4( 0.0, 0.0, 0.0, 1.0);
	vec4 box_vertex_ndc = MVP * vec4( vPos.x, vPos.y , 0.0, 1.0) ;
	vec4 box_right_edge_mid_point_ndc = MVP * vec4(vPos.x , 0.0, 0.0, 1.0 );
	vec4 box_top_edge_mid_point_ndc = MVP * vec4(0.0,  vPos.y, 0.0, 1.0 );	

	// Calculate important box vectors in ndc
	vec2 box_center_to_right_edge_midpoint_ndc = vec2( box_right_edge_mid_point_ndc.x - box_center_ndc.x , box_right_edge_mid_point_ndc.y - box_center_ndc.y);
	vec2 box_center_to_top_edge_midpoint_ndc = vec2( box_top_edge_mid_point_ndc.x - box_center_ndc.x , box_top_edge_mid_point_ndc.y - box_center_ndc.y);
	vec2 box_right_edge_normal_ndc = normalize( box_center_to_right_edge_midpoint_ndc );
	vec2 box_top_edge_normal_ndc = normalize( box_center_to_top_edge_midpoint_ndc );
	vec2 box_vertex_ndc_traslation = normalize( box_right_edge_normal_ndc + box_top_edge_normal_ndc ) ;

	// Questi possono sostituire "border_width" nel calcolo delle exploded_box_center_to_[right|top]_edge_midpoint_ndc;
	// Tuttavia, probabilmente per motivi numerici, si ha un risultato corretto solo in assenza di rotazioni del box.
	// Si sceglie dunque di utilizzare direttamente border_width che, nonostante non faccia combaciare il bordo in modo
	// estremamente esatto, produce un risultato accettabile (specie quando border_width Ã¨ piccolo).
	// float rigth_edge_width = dot( box_right_edge_normal_ndc, box_vertex_ndc_traslation );
	// float top_edge_width = dot( box_top_edge_normal_ndc, box_vertex_ndc_traslation );
	
	// Apply corrective factors (read notes at the bottom)
	box_vertex_ndc_traslation.x = box_vertex_ndc_traslation.x / screen_width_ratio;
	box_right_edge_normal_ndc.x = box_right_edge_normal_ndc.x / screen_width_ratio;
	box_top_edge_normal_ndc.x = box_top_edge_normal_ndc.x / screen_width_ratio;

	vec2 exploded_box_center_to_right_edge_midpoint_ndc = box_center_to_right_edge_midpoint_ndc + box_right_edge_normal_ndc * border_width;
	vec2 exploded_box_center_to_top_edge_midpoint_ndc = box_center_to_top_edge_midpoint_ndc + box_top_edge_normal_ndc * border_width;
	
	// Generate vertex shaders outputs
	float half_width_ndc = length( box_center_to_right_edge_midpoint_ndc );
	float half_height_ndc = length( box_center_to_top_edge_midpoint_ndc );
	float exploded_half_width_ndc = length( exploded_box_center_to_right_edge_midpoint_ndc );
	float exploded_half_height_ndc = length( exploded_box_center_to_top_edge_midpoint_ndc );
	vs_out.borderCoord = vec2( 
				( exploded_half_width_ndc * outline) / half_width_ndc * sign(vPos.x) ,
			    ( exploded_half_height_ndc * outline) / half_height_ndc * sign(vPos.y) );
				
	vec2 sum = box_right_edge_normal_ndc + box_top_edge_normal_ndc;
	vs_out.vertex_normal_ndc = sum;
	//vs_out.vertex_normal_ndc = (box_center_to_right_edge_midpoint_ndc + box_center_to_top_edge_midpoint_ndc);
	gl_Position = vec4( box_vertex_ndc.x + box_vertex_ndc_traslation.x * border_width , box_vertex_ndc.y + box_vertex_ndc_traslation.y  * border_width , outline * 0.5, 1.0 );

}


void main()
{

	float border_width = 0.1f * outline;

	// Transform important box points to ndc
	vec4 box_center_ndc = MVP * vec4( 0.0, 0.0, 0.0, 1.0);
	vec4 box_vertex_ndc = MVP * vec4( vPos.x, vPos.y , 0.0, 1.0) ;
	vec4 box_right_edge_mid_point_ndc = MVP * vec4(vPos.x , 0.0, 0.0, 1.0 );
	vec4 box_top_edge_mid_point_ndc = MVP * vec4(0.0,  vPos.y, 0.0, 1.0 );

	vec4 box_right_edge_normal_ndc_tmp = MVP * vec4(sign(vPos.x) , 0.0, 0.0, 1.0 );
	vec4 box_top_edge_normal_ndc_tmp = MVP * vec4(0.0 , sign(vPos.y), 0.0, 1.0 );

	//vec2 box_right_edge_normal_ndc = vec2( box_right_edge_normal_ndc_tmp.x - box_center_ndc.x , box_right_edge_normal_ndc_tmp.y - box_center_ndc.y);
	//vec2 box_top_edge_normal_ndc = vec2( box_top_edge_normal_ndc_tmp.x - box_center_ndc.x , box_top_edge_normal_ndc_tmp.y - box_center_ndc.y);

	// Calculate important box vectors in ndc
	vec2 box_center_to_right_edge_midpoint_ndc = vec2( box_right_edge_mid_point_ndc.x - box_center_ndc.x , box_right_edge_mid_point_ndc.y - box_center_ndc.y);
	vec2 box_center_to_top_edge_midpoint_ndc = vec2( box_top_edge_mid_point_ndc.x - box_center_ndc.x , box_top_edge_mid_point_ndc.y - box_center_ndc.y);
	box_center_to_right_edge_midpoint_ndc.x = box_center_to_right_edge_midpoint_ndc.x * screen_width_ratio;
	box_center_to_top_edge_midpoint_ndc.x = box_center_to_top_edge_midpoint_ndc.x * screen_width_ratio;
	vec2 box_right_edge_normal_ndc = normalize( box_center_to_right_edge_midpoint_ndc );
	vec2 box_top_edge_normal_ndc = normalize( box_center_to_top_edge_midpoint_ndc );
	vec2 box_vertex_ndc_traslation = normalize( box_right_edge_normal_ndc + box_top_edge_normal_ndc ) ;

	

	float rigth_edge_width = dot( box_right_edge_normal_ndc, box_vertex_ndc_traslation ) ;
	float top_edge_width = dot( box_top_edge_normal_ndc, box_vertex_ndc_traslation ) ;

	// Apply corrective factors (read notes at the bottom)
	box_vertex_ndc_traslation.x = box_vertex_ndc_traslation.x / screen_width_ratio;
	//box_right_edge_normal_ndc.x = box_right_edge_normal_ndc.x / screen_width_ratio;
	//box_top_edge_normal_ndc.x = box_top_edge_normal_ndc.x / screen_width_ratio;


	vec2 exploded_box_center_to_right_edge_midpoint_ndc = box_center_to_right_edge_midpoint_ndc + box_right_edge_normal_ndc * rigth_edge_width;
	vec2 exploded_box_center_to_top_edge_midpoint_ndc = box_center_to_top_edge_midpoint_ndc + box_top_edge_normal_ndc * top_edge_width;
	
	//box_center_to_right_edge_midpoint_ndc.x = box_center_to_right_edge_midpoint_ndc.x * screen_width_ratio;
	//box_center_to_top_edge_midpoint_ndc.x = box_center_to_top_edge_midpoint_ndc.x * screen_width_ratio;
	//exploded_box_center_to_right_edge_midpoint_ndc.x = exploded_box_center_to_right_edge_midpoint_ndc.x * screen_width_ratio;
	//exploded_box_center_to_top_edge_midpoint_ndc.x = exploded_box_center_to_top_edge_midpoint_ndc.x * screen_width_ratio;

	// Generate vertex shaders outputs
	float half_width_ndc = length( box_center_to_right_edge_midpoint_ndc );
	float half_height_ndc = length( box_center_to_top_edge_midpoint_ndc );
	float exploded_half_width_ndc = length( exploded_box_center_to_right_edge_midpoint_ndc );
	float exploded_half_height_ndc = length( exploded_box_center_to_top_edge_midpoint_ndc );
	vs_out.borderCoord = vec2( 
				( exploded_half_width_ndc * outline) / half_width_ndc * sign(vPos.x) ,
			    ( exploded_half_height_ndc * outline) / half_height_ndc * sign(vPos.y) );
	
	
	vs_out.vertex_normal_ndc = box_right_edge_normal_ndc;

	vec2 sum = box_right_edge_normal_ndc + box_top_edge_normal_ndc;
	sum = normalize(sum);

	//vs_out.debug_color = vec3( box_right_edge_normal_ndc.x + box_top_edge_normal_ndc.x , box_right_edge_normal_ndc.y + box_top_edge_normal_ndc.y  , 0 );
	//vs_out.debug_color = vec3( sign(vPos.x), sign(vPos.y) , 0 );
	vs_out.debug_color = vec3( ( exploded_half_width_ndc ) / half_width_ndc * sign(vPos.x), ( exploded_half_height_ndc ) / half_height_ndc * sign(vPos.y), 0 );
	
	//if( value < (0.6 + 0.05) && value > (0.6 - 0.05)) {
	//	debug_color = vec3( 0 , 1, 0 );
	//}else{
	//	debug_color = vec3(1 , 0, 0 );
	//}

	gl_Position = vec4( box_vertex_ndc.x + box_vertex_ndc_traslation.x * border_width , box_vertex_ndc.y + box_vertex_ndc_traslation.y  * border_width , outline * 0.5, 1.0 );

	//box_center_to_right_edge_midpoint_ndc.x = box_center_to_right_edge_midpoint_ndc.x / screen_width_ratio;
	//box_center_to_top_edge_midpoint_ndc.x = box_center_to_top_edge_midpoint_ndc.x / screen_width_ratio;
	box_vertex_ndc_traslation.x = box_vertex_ndc_traslation.x * screen_width_ratio;
	//box_vertex_ndc_traslation = box_vertex_ndc_traslation * border_width;
	//box_vertex_ndc_traslation.x = box_vertex_ndc_traslation.x / screen_width_ratio;

	vec2 norm_right = normalize(box_center_to_right_edge_midpoint_ndc);
	vec2 norm_top = normalize(box_center_to_top_edge_midpoint_ndc);

	float len_right = length(box_center_to_right_edge_midpoint_ndc);
	float len_top = length(box_center_to_top_edge_midpoint_ndc);
	
	float len_right_out = length(box_center_to_right_edge_midpoint_ndc + norm_right * dot(norm_right, box_vertex_ndc_traslation * border_width));
	float len_top_out = length(box_center_to_top_edge_midpoint_ndc + norm_top * dot(norm_top, box_vertex_ndc_traslation * border_width));

	vs_out.borderCoord = vec2( 
			( len_right_out * outline) / len_right * sign(vPos.x) ,
			( len_top_out * outline) / len_top * sign(vPos.y) );
	
	vs_out.debug_color = vec3( ( len_right_out ) / len_right * sign(vPos.x), ( len_top_out ) / len_top * sign(vPos.y), 0 );

}



void mainDEBUGOLD2()
{

	float border_width = 0.1f * outline;

	// Transform important box points to ndc
	vec4 box_center_ndc = MVP * vec4( 0.0, 0.0, 0.0, 1.0);
	vec4 box_vertex_ndc = MVP * vec4( vPos.x, vPos.y , 0.0, 1.0) ;
	vec4 box_right_edge_mid_point_ndc = MVP * vec4(vPos.x , 0.0, 0.0, 1.0 );
	vec4 box_top_edge_mid_point_ndc = MVP * vec4(0.0,  vPos.y, 0.0, 1.0 );

	vec4 box_right_edge_normal_ndc_tmp = MVP * vec4(sign(vPos.x) , 0.0, 0.0, 1.0 );
	vec4 box_top_edge_normal_ndc_tmp = MVP * vec4(0.0 , sign(vPos.y), 0.0, 1.0 );

	//vec2 box_right_edge_normal_ndc = vec2( box_right_edge_normal_ndc_tmp.x - box_center_ndc.x , box_right_edge_normal_ndc_tmp.y - box_center_ndc.y);
	//vec2 box_top_edge_normal_ndc = vec2( box_top_edge_normal_ndc_tmp.x - box_center_ndc.x , box_top_edge_normal_ndc_tmp.y - box_center_ndc.y);

	// Calculate important box vectors in ndc
	vec2 box_center_to_right_edge_midpoint_ndc = vec2( box_right_edge_mid_point_ndc.x - box_center_ndc.x , box_right_edge_mid_point_ndc.y - box_center_ndc.y);
	vec2 box_center_to_top_edge_midpoint_ndc = vec2( box_top_edge_mid_point_ndc.x - box_center_ndc.x , box_top_edge_mid_point_ndc.y - box_center_ndc.y);

	//box_center_to_right_edge_midpoint_ndc.x = box_center_to_right_edge_midpoint_ndc.x / screen_width_ratio;
	//box_center_to_top_edge_midpoint_ndc.x = box_center_to_top_edge_midpoint_ndc.x / screen_width_ratio;

	vec2 box_right_edge_normal_ndc = normalize( box_center_to_right_edge_midpoint_ndc );
	vec2 box_top_edge_normal_ndc = normalize( box_center_to_top_edge_midpoint_ndc );
	vec2 box_vertex_ndc_traslation = normalize( box_right_edge_normal_ndc + box_top_edge_normal_ndc ) ;

	// Questi possono sostituire "border_width" nel calcolo delle exploded_box_center_to_[right|top]_edge_midpoint_ndc;
	// Tuttavia, probabilmente per problemi con l'interpolazione, si ha un risultato corretto solo 
	// in assenza di rotazioni del box, quando tutti i prodotti scalari sono fatti includendo vettori allineati col sistema di coordinate.
	// Si sceglie dunque di utilizzare direttamente border_width che, nonostante non faccia combaciare il bordo in modo
	// estremamente esatto, produce un risultato accettabile (specie quando border_width Ã¨ piccolo).
	float rigth_edge_width = dot( box_right_edge_normal_ndc, box_vertex_ndc_traslation ) ;
	float top_edge_width = dot( box_top_edge_normal_ndc, box_vertex_ndc_traslation ) ;
	
	
	// Apply corrective factors (read notes at the bottom)
	box_vertex_ndc_traslation.x = box_vertex_ndc_traslation.x / screen_width_ratio;
	//box_right_edge_normal_ndc.x = box_right_edge_normal_ndc.x / screen_width_ratio;
	//box_top_edge_normal_ndc.x = box_top_edge_normal_ndc.x / screen_width_ratio;



	

	vec2 exploded_box_center_to_right_edge_midpoint_ndc = box_center_to_right_edge_midpoint_ndc + box_right_edge_normal_ndc * rigth_edge_width;
	vec2 exploded_box_center_to_top_edge_midpoint_ndc = box_center_to_top_edge_midpoint_ndc + box_top_edge_normal_ndc * top_edge_width;
	
	//box_center_to_right_edge_midpoint_ndc.x = box_center_to_right_edge_midpoint_ndc.x * screen_width_ratio;
	//box_center_to_top_edge_midpoint_ndc.x = box_center_to_top_edge_midpoint_ndc.x * screen_width_ratio;
	//exploded_box_center_to_right_edge_midpoint_ndc.x = exploded_box_center_to_right_edge_midpoint_ndc.x * screen_width_ratio;
	//exploded_box_center_to_top_edge_midpoint_ndc.x = exploded_box_center_to_top_edge_midpoint_ndc.x * screen_width_ratio;

	// Generate vertex shaders outputs
	float half_width_ndc = length( box_center_to_right_edge_midpoint_ndc );
	float half_height_ndc = length( box_center_to_top_edge_midpoint_ndc );
	float exploded_half_width_ndc = length( exploded_box_center_to_right_edge_midpoint_ndc );
	float exploded_half_height_ndc = length( exploded_box_center_to_top_edge_midpoint_ndc );
	vs_out.borderCoord = vec2( 
				( exploded_half_width_ndc * outline) / half_width_ndc * sign(vPos.x) ,
			    ( exploded_half_height_ndc * outline) / half_height_ndc * sign(vPos.y) );
	
	
	vs_out.vertex_normal_ndc = box_right_edge_normal_ndc;

	vec2 sum = box_right_edge_normal_ndc + box_top_edge_normal_ndc;
	sum = normalize(sum);

	//vs_out.debug_color = vec3( box_right_edge_normal_ndc.x + box_top_edge_normal_ndc.x , box_right_edge_normal_ndc.y + box_top_edge_normal_ndc.y  , 0 );
	vs_out.debug_color = vec3( sign(vPos.x), sign(vPos.y) , 0 );
	
	//if( value < (0.6 + 0.05) && value > (0.6 - 0.05)) {
	//	debug_color = vec3( 0 , 1, 0 );
	//}else{
	//	debug_color = vec3(1 , 0, 0 );
	//}

	gl_Position = vec4( box_vertex_ndc.x + box_vertex_ndc_traslation.x * border_width , box_vertex_ndc.y + box_vertex_ndc_traslation.y  * border_width , outline * 0.5, 1.0 );

	

}




// L'idea Ã¨ questa:
// Trasformo il box in ndc, assieme alle normali dei suoi edges
// Quindi traslo i vertici per le rispettive normali degli edges adiacenti cosÃ¬
// da creare un bordo
// Infine associo al vertice una coordinata con valore assoluto maggiore di 1, 
// nella speranza che tra 1+x e 1 compaia il bordo mentre da 1 a 0 il box originale.
void mai_OLD_DEBUG()
{

	float border_width = 0.4f * outline;

	// Transform important box points to ndc
	vec4 box_center_ndc = MVP * vec4( 0.0, 0.0, 0.0, 1.0);
	vec4 box_vertex_ndc = MVP * vec4( vPos.x, vPos.y , 0.0, 1.0) ;
	vec4 box_right_edge_mid_point_ndc = MVP * vec4(vPos.x , 0.0, 0.0, 1.0 );
	vec4 box_top_edge_mid_point_ndc = MVP * vec4(0.0,  vPos.y, 0.0, 1.0 );	

	// Calculate important box vectors in ndc
	vec2 box_center_to_right_edge_midpoint_ndc = vec2( box_right_edge_mid_point_ndc.x - box_center_ndc.x , box_right_edge_mid_point_ndc.y - box_center_ndc.y);
	vec2 box_center_to_top_edge_midpoint_ndc = vec2( box_top_edge_mid_point_ndc.x - box_center_ndc.x , box_top_edge_mid_point_ndc.y - box_center_ndc.y);
	//box_center_to_right_edge_midpoint_ndc.x = box_center_to_right_edge_midpoint_ndc.x * screen_width_ratio;
	//box_center_to_top_edge_midpoint_ndc.x = box_center_to_top_edge_midpoint_ndc.x * screen_width_ratio;
	//vec2 box_right_edge_normal_ndc = normalize( box_center_to_right_edge_midpoint_ndc );
	//vec2 box_top_edge_normal_ndc = normalize( box_center_to_top_edge_midpoint_ndc );
	float norm_A = 1.0f / length(box_center_to_right_edge_midpoint_ndc);
	float norm_B = 1.0f / length(box_center_to_top_edge_midpoint_ndc);
	// CON VALORI COSTANTI WORKA, Ã¨ proprio nel length il problema?? varia quando gira il box?? (Ã¨ differente per i diversi vertici)
	// CON VALORI COSTANTI WORKA
	// CON VALORI COSTANTI WORKA MA PERCHE' ALLORA NON WORKA CON 1/leght??
	//float norm_A = 2f;
	//float norm_B = 2f;
	vec2 box_right_edge_normal_ndc =  box_center_to_right_edge_midpoint_ndc * norm_A;
	vec2 box_top_edge_normal_ndc = box_center_to_top_edge_midpoint_ndc * norm_B;
	vec2 box_vertex_ndc_traslation = normalize( box_right_edge_normal_ndc + box_top_edge_normal_ndc ) ;

	// Questi possono sostituire "border_width" nel calcolo delle exploded_box_center_to_[right|top]_edge_midpoint_ndc;
	// Tuttavia, probabilmente per problemi con l'interpolazione, si ha un risultato corretto solo 
	// in assenza di rotazioni del box, quando tutti i prodotti scalari sono fatti includendo vettori allineati col sistema di coordinate.
	// Si sceglie dunque di utilizzare direttamente border_width che, nonostante non faccia combaciare il bordo in modo
	// estremamente esatto, produce un risultato accettabile (specie quando border_width Ã¨ piccolo).
	float rigth_edge_width = dot( box_right_edge_normal_ndc, box_vertex_ndc_traslation ) ;
	float top_edge_width = dot( box_top_edge_normal_ndc, box_vertex_ndc_traslation ) ;
	
	// Il valore di debug_color di ogni vertice Ã¨ diverso ad ogni differente rotazione del cubo.
	// Se ogni vertice avesse sempre lo stesso valore, allora il risultato dell'interpolazione sarebbe sempre lo stesso a prescindere dalla rotazione.
	// Ma se il valore di ogni vertice VARIA in base alla rotazione, l'interpolazione non lavora sempre sugli stessi valori e potrebbe esserci
	// dell'incoerenza.
	
	//debug_color = vec3( vPos.x * 100, vPos.y * 100, 0 );
	//debug_color = vec3( (box_right_edge_normal_ndc.x + box_top_edge_normal_ndc.x) * 100, (box_right_edge_normal_ndc.y + box_top_edge_normal_ndc.y) * 100, 0 );
	//debug_color = vec3( box_vertex_ndc.x * 100, box_vertex_ndc.y * 100, 0 );

	//debug_color = vec3( (box_center_to_right_edge_midpoint_ndc.x + box_center_to_top_edge_midpoint_ndc.x) * 100, (box_center_to_right_edge_midpoint_ndc.y + box_center_to_top_edge_midpoint_ndc.y) * 100, 0 );
	box_right_edge_normal_ndc.y = box_right_edge_normal_ndc.y * screen_width_ratio;
	box_top_edge_normal_ndc.y = box_top_edge_normal_ndc.y * screen_width_ratio;
	vs_out.debug_color = vec3( (box_right_edge_normal_ndc.x + box_top_edge_normal_ndc.x) *100 , (box_right_edge_normal_ndc.y + box_top_edge_normal_ndc.y)*100 , 0 );
	//debug_color = vec3( (box_center_to_right_edge_midpoint_ndc.x ) , (box_center_to_right_edge_midpoint_ndc.y ) , 0 );

	//debug_color = vec3( norm_A / 10, 0, 0 ); 
	
	//if(norm_B > 1.0){
	//	debug_color = vec3( 0 , 1, 0 );
	//}else{
	//	debug_color = vec3(1 , 0, 0 );
	//}
	

	// OSSERVAZIONE IMPORTANTE:
	// Impostando su tutti i vertici un debuc_color pari alla lunghezza di box_center_to_right_edge_midpoint_ndc, si nota che il colore del rettangolo
	// cambia in relazione alla rotazione.
	//debug_color = vec3( length(box_center_to_right_edge_midpoint_ndc) , 0, 0 );

	//if(length(box_center_to_right_edge_midpoint_ndc) < 0.04999999888){
	//	debug_color = vec3( 0 , 1, 0 );
	//}else{
	//	debug_color = vec3(1 , 0, 0 );
	//}

	float value = length(box_center_to_top_edge_midpoint_ndc) + length(box_center_to_right_edge_midpoint_ndc);

	//if( value < (0.6 + 0.05) && value > (0.6 - 0.05)) {
	//	debug_color = vec3( 0 , 1, 0 );
	//}else{
	//	debug_color = vec3(1 , 0, 0 );
	//}

	// Apply corrective factors (read notes at the bottom)
	box_vertex_ndc_traslation.x = box_vertex_ndc_traslation.x / screen_width_ratio;
	box_right_edge_normal_ndc.x = box_right_edge_normal_ndc.x / screen_width_ratio;
	box_top_edge_normal_ndc.x = box_top_edge_normal_ndc.x / screen_width_ratio;


	

	vec2 exploded_box_center_to_right_edge_midpoint_ndc = box_center_to_right_edge_midpoint_ndc + box_right_edge_normal_ndc * rigth_edge_width;
	vec2 exploded_box_center_to_top_edge_midpoint_ndc = box_center_to_top_edge_midpoint_ndc + box_top_edge_normal_ndc * top_edge_width;

	
	//vec2 exploded_box_center_to_right_edge_midpoint_ndc = box_center_to_right_edge_midpoint_ndc + box_vertex_ndc_traslation ;
	//vec2 exploded_box_center_to_top_edge_midpoint_ndc = box_center_to_top_edge_midpoint_ndc + box_vertex_ndc_traslation ;
	
	// Generate vertex shaders outputs
	float half_width_ndc = length( box_center_to_right_edge_midpoint_ndc );
	float half_height_ndc = length( box_center_to_top_edge_midpoint_ndc );
	float exploded_half_width_ndc = length( exploded_box_center_to_right_edge_midpoint_ndc );
	float exploded_half_height_ndc = length( exploded_box_center_to_top_edge_midpoint_ndc );
	vs_out.borderCoord = vec2( 
				( exploded_half_width_ndc * outline) / half_width_ndc * sign(vPos.x) ,
			    ( exploded_half_height_ndc * outline) / half_height_ndc * sign(vPos.y) );
	//vs_out.vertex_normal_ndc = box_right_edge_normal_ndc + box_top_edge_normal_ndc;
	vec2 sum = box_right_edge_normal_ndc + box_top_edge_normal_ndc;
	vs_out.vertex_normal_ndc = sum;

	gl_Position = vec4( box_vertex_ndc.x + box_vertex_ndc_traslation.x * border_width , box_vertex_ndc.y + box_vertex_ndc_traslation.y  * border_width , outline * 0.5, 1.0 );

	

}

// About corrective factors:
//
// 1) MAPPINGS: 
// The mvp (the VIEW matrix in particular) is built by specifying the game world units that are confined 
// between the left, right, top and bottom borders of the camera (technically speaking, the frustum 
// parameters r, l, t, b).
//
// The MVP projection is such that the following mappings happens between the game world units and the ndc system:
//
// 		l -> x -1
//		r -> x  1
//		b -> y -1
// 		t -> y  1 
//
// Then there is the viewport which an actual area of the monitor specified by a pixel width and a pixel 
// height (vp_width, vp_height); the ndc space is mapped into it with the following mappings:
//
//		x -1 -> 0 px
//  	x  1 -> vp_width px
//  	y -1 -> 0 px
//  	y  1 -> vp_height px
//
// 2) CORRECTIVE FACTORS
// screen_width_ratio contiene il rapporto vp_width/vp_height che Ã¨ lo stesso (per come Ã¨ fatto il codice)
// del rapporto l-r / t-b (ovvero quello che cÃ¨ tra camera fov width e camera fov height)
// 
// TUTTAVIA, quando siamo in NDC, non esiste piÃ¹ un rapporto screen_width_ratio tra la dimensione orizzontale
// e la dimensione verticale; per questo motivo va imposto il suddetto ratio quando si manipola oggetti in NDC
// e si vuole rifarsi a dimensioni VALIDE in entrambe le dimensioni (altrimenti "0.1" unitÃ  in orizzontale non
// corrispondono a "0.1" unitÃ  in verticale, ma le 0.1 orizzontali prendono piÃ¹ schermo)
//
// NOTA: Border coord:
// Sostanzialmente associo al vertice corrente una UV MAGGIORE di 1, con la speranza che poi, a uv coord di 1 cÃ¨ l'attuale 
// box, mentre tra 1 e 1+x cÃ¨ il bordo (che quindi nel fragment shader Ã¨ colorato di bianco)
// 


void old_main()
{

	float border_width = 0.1f * outline;

	// Transform important box points to ndc
	vec4 box_center_ndc = MVP * vec4( 0.0, 0.0, 0.0, 1.0);
	vec4 box_vertex_ndc = MVP * vec4( vPos.x, vPos.y , 0.0, 1.0) ;
	vec4 box_vertical_edge_mid_point_ndc = MVP * vec4(vPos.x , 0.0, 0.0, 1.0 );
	vec4 box_horizontal_edge_mid_point_ndc = MVP * vec4(0.0,  vPos.y, 0.0, 1.0 );	

	// Calculate important box vectors in ndc
	vec2 box_center_to_vertical_edge_midpoint_ndc = vec2( box_vertical_edge_mid_point_ndc.x - box_center_ndc.x , box_vertical_edge_mid_point_ndc.y - box_center_ndc.y);
	vec2 box_center_to_horizontal_edge_midpoint_ndc = vec2( box_horizontal_edge_mid_point_ndc.x - box_center_ndc.x , box_horizontal_edge_mid_point_ndc.y - box_center_ndc.y);
	vec2 box_vertical_edge_normal_ndc = normalize( box_center_to_vertical_edge_midpoint_ndc );
	vec2 box_horizontal_edge_normal_ndc = normalize( box_center_to_horizontal_edge_midpoint_ndc );
	vec2 box_vertex_ndc_traslation = normalize( box_vertical_edge_normal_ndc + box_horizontal_edge_normal_ndc ) * border_width;

	// Apply corrective factors
	box_vertex_ndc_traslation.x = box_vertex_ndc_traslation.x / screen_width_ratio;
	//box_center_to_vertical_edge_midpoint_ndc.x = box_center_to_vertical_edge_midpoint_ndc.x * screen_width_ratio;
	//box_center_to_horizontal_edge_midpoint_ndc.x = box_center_to_horizontal_edge_midpoint_ndc.x * screen_width_ratio;

	// Generate vertex shaders outputs
	float half_width_ndc = length( box_center_to_vertical_edge_midpoint_ndc );
	float half_height_ndc = length( box_center_to_horizontal_edge_midpoint_ndc );
	vs_out.borderCoord = vec2( 
				( half_width_ndc + border_width ) / half_width_ndc * sign(vPos.x) ,
			    ( half_height_ndc + border_width ) / half_height_ndc * sign(vPos.y) );
	gl_Position = vec4( box_vertex_ndc.x + box_vertex_ndc_traslation.x  , box_vertex_ndc.y + box_vertex_ndc_traslation.y  , outline * 0.5, 1.0 );

}

void BACKUPmain()
{

	float border_width = 0.01f * outline;

	// Transform important box points to ndc
	vec4 box_center_ndc = MVP * vec4( 0.0, 0.0, 0.0, 1.0);
	vec4 box_vertex_ndc = MVP * vec4( vPos.x, vPos.y , 0.0, 1.0) ;
	vec4 box_right_edge_mid_point_ndc = MVP * vec4(vPos.x , 0.0, 0.0, 1.0 );
	vec4 box_top_edge_mid_point_ndc = MVP * vec4(0.0,  vPos.y, 0.0, 1.0 );	

	// Calculate important box vectors in ndc
	vec2 box_center_to_right_edge_midpoint_ndc = vec2( box_right_edge_mid_point_ndc.x - box_center_ndc.x , box_right_edge_mid_point_ndc.y - box_center_ndc.y);
	vec2 box_center_to_top_edge_midpoint_ndc = vec2( box_top_edge_mid_point_ndc.x - box_center_ndc.x , box_top_edge_mid_point_ndc.y - box_center_ndc.y);
	vec2 box_right_edge_normal_ndc = normalize( box_center_to_right_edge_midpoint_ndc );
	vec2 box_top_edge_normal_ndc = normalize( box_center_to_top_edge_midpoint_ndc );
	vec2 box_vertex_ndc_traslation = normalize( box_right_edge_normal_ndc + box_top_edge_normal_ndc ) ;

	// Questi possono sostituire "border_width" nel calcolo delle exploded_box_center_to_[right|top]_edge_midpoint_ndc;
	// Tuttavia, probabilmente per motivi numerici, si ha un risultato corretto solo in assenza di rotazioni del box.
	// Si sceglie dunque di utilizzare direttamente border_width che, nonostante non faccia combaciare il bordo in modo
	// estremamente esatto, produce un risultato accettabile (specie quando border_width Ã¨ piccolo).
	// float rigth_edge_width = dot( box_right_edge_normal_ndc, box_vertex_ndc_traslation );
	// float top_edge_width = dot( box_top_edge_normal_ndc, box_vertex_ndc_traslation );
	
	// Apply corrective factors (read notes at the bottom)
	box_vertex_ndc_traslation.x = box_vertex_ndc_traslation.x / screen_width_ratio;
	box_right_edge_normal_ndc.x = box_right_edge_normal_ndc.x / screen_width_ratio;
	box_top_edge_normal_ndc.x = box_top_edge_normal_ndc.x / screen_width_ratio;

	vec2 exploded_box_center_to_right_edge_midpoint_ndc = box_center_to_right_edge_midpoint_ndc + box_right_edge_normal_ndc * border_width;
	vec2 exploded_box_center_to_top_edge_midpoint_ndc = box_center_to_top_edge_midpoint_ndc + box_top_edge_normal_ndc * border_width;
	
	// Generate vertex shaders outputs
	float half_width_ndc = length( box_center_to_right_edge_midpoint_ndc );
	float half_height_ndc = length( box_center_to_top_edge_midpoint_ndc );
	float exploded_half_width_ndc = length( exploded_box_center_to_right_edge_midpoint_ndc );
	float exploded_half_height_ndc = length( exploded_box_center_to_top_edge_midpoint_ndc );
	vs_out.borderCoord = vec2( 
				( exploded_half_width_ndc * outline) / half_width_ndc * sign(vPos.x) ,
			    ( exploded_half_height_ndc * outline) / half_height_ndc * sign(vPos.y) );
	vs_out.vertex_normal_ndc = box_right_edge_normal_ndc + box_top_edge_normal_ndc;
	gl_Position = vec4( box_vertex_ndc.x + box_vertex_ndc_traslation.x * border_width , box_vertex_ndc.y + box_vertex_ndc_traslation.y  * border_width , outline * 0.5, 1.0 );

}